(function() {
    // evita duplo carregamento
    if (document.getElementById('bmSplash')) return;

    // --- Constantes ---
    const MIN_DELAY = 1;
    const SCROLL_DELAY = 50;
    const STEP_DELAY = MIN_DELAY;
    // MIN_WRAPPER_WIDTH/HEIGHT removidos (agora no CSS)

    // --- FUNÇÕES AUXILIARES ---
    function showCustomAlert(message, type = 'info') { /* ... código mantido (com ícones) ... */
        const existingOverlay = document.getElementById('bmAlertOverlay'); if (existingOverlay) { existingOverlay.remove(); } const overlay = document.createElement('div'); overlay.id = 'bmAlertOverlay'; const alertBox = document.createElement('div'); alertBox.id = 'bmAlertBox'; alertBox.classList.add(`bmAlert-${type}`); let iconHtml = ''; switch (type) { case 'error': iconHtml = '<div class="bmAlertIcon error">!</div>'; break; case 'warning': iconHtml = '<div class="bmAlertIcon warning">!</div>'; break; case 'success': iconHtml = '<div class="bmAlertIcon success">✓</div>'; break; case 'info': default: iconHtml = '<div class="bmAlertIcon info">i</div>'; break; } const messageP = document.createElement('p'); messageP.id = 'bmAlertMessage'; messageP.textContent = message; const closeBtn = document.createElement('button'); closeBtn.id = 'bmAlertCloseBtn'; closeBtn.textContent = 'OK'; closeBtn.onclick = () => { alertBox.classList.remove('bmAlertEnter'); alertBox.classList.add('bmAlertExit'); overlay.classList.add('bmAlertFadeOut'); setTimeout(() => { if (document.body.contains(overlay)) { document.body.removeChild(overlay); } }, 400); }; alertBox.innerHTML = iconHtml; alertBox.appendChild(messageP); alertBox.appendChild(closeBtn); overlay.appendChild(alertBox); document.body.appendChild(overlay); void alertBox.offsetWidth; overlay.classList.add('bmAlertFadeIn'); alertBox.classList.add('bmAlertEnter');
    }
    function waitForElementToDisappear(selector, timeout = 30000) { /* ... código mantido ... */
        return new Promise((resolve, reject) => { const intervalTime = 50; let elapsedTime = 0; const intervalId = setInterval(() => { const element = document.querySelector(selector); if (!element) { clearInterval(intervalId); clearTimeout(timeoutId); resolve("Elemento desapareceu"); } elapsedTime += intervalTime; }, intervalTime); const timeoutId = setTimeout(() => { clearInterval(intervalId); console.error(`Timeout ${timeout}ms esperando ${selector} desaparecer.`); reject(new Error(`Timeout esperando ${selector} desaparecer`)); }, timeout); });
    }
    function waitForElement(selector, timeout = 5000) { /* ... código mantido ... */
        return new Promise((resolve, reject) => { const startTime = Date.now(); const interval = setInterval(() => { const element = document.querySelector(selector); if (element && element.offsetParent !== null) { clearInterval(interval); resolve(element); } else if (Date.now() - startTime > timeout) { clearInterval(interval); reject(new Error(`Timeout: ${selector}`)); } }, 50); });
    }

    // --- RASTREAMENTO DO ELEMENTO ATIVO ---
    let activeEl = null; document.addEventListener('mousedown', e => { activeEl = e.target; }, true);

    // --- FUNÇÕES DE SIMULAÇÃO DE TECLADO (Aceleradas) ---
    function dispatchKeyEvent(target, eventType, key, keyCode, charCode = 0) { /* ... código mantido ... */
        let effectiveCharCode = charCode; if (!effectiveCharCode && key && key.length === 1) { effectiveCharCode = key.charCodeAt(0); } const event = new KeyboardEvent(eventType, { key: key, code: `Key${key.toUpperCase()}`, keyCode: keyCode, which: keyCode, charCode: eventType === 'keypress' ? effectiveCharCode : 0, bubbles: true, cancelable: true }); target.dispatchEvent(event);
    }
    async function simulateBackspace(targetElement) { /* ... código mantido ... */
        if (!targetElement) return; activeEl = targetElement; targetElement.focus({ preventScroll: true }); const start = targetElement.selectionStart; const end = targetElement.selectionEnd; dispatchKeyEvent(targetElement, 'keydown', 'Backspace', 8); if ((targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA')) { const currentValue = targetElement.value; let newValue = currentValue; let newCursorPos = start; if (start === end && start > 0) { newValue = currentValue.substring(0, start - 1) + currentValue.substring(end); newCursorPos = start - 1; } else if (start !== end) { newValue = currentValue.substring(0, start) + currentValue.substring(end); newCursorPos = start; } if (newValue !== currentValue) { const prototype = Object.getPrototypeOf(targetElement); const descriptor = Object.getOwnPropertyDescriptor(prototype, 'value'); if (descriptor && descriptor.set) { descriptor.set.call(targetElement, newValue); } else { targetElement.value = newValue; } targetElement.selectionStart = targetElement.selectionEnd = newCursorPos; targetElement.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); targetElement.dispatchEvent(new Event('change', { bubbles: true, cancelable: true })); } } else if (targetElement.isContentEditable) { document.execCommand('delete', false, null); } dispatchKeyEvent(targetElement, 'keyup', 'Backspace', 8); if(MIN_DELAY > 0) await new Promise(r => setTimeout(r, MIN_DELAY));
    }
    function sendChar(c) { /* ... código mantido ... */
        if (!activeEl || !document.body.contains(activeEl)) { return false; } const targetElement = activeEl; targetElement.focus({ preventScroll: true }); const keyCode = c.charCodeAt(0); dispatchKeyEvent(targetElement, 'keydown', c, keyCode); dispatchKeyEvent(targetElement, 'keypress', c, keyCode, keyCode); if (targetElement.isContentEditable) { document.execCommand('insertText', false, c); } else if (targetElement.tagName === 'INPUT' || targetElement.tagName === 'TEXTAREA') { const start = targetElement.selectionStart; const end = targetElement.selectionEnd; const currentValue = targetElement.value; const newValue = currentValue.substring(0, start) + c + currentValue.substring(end); const prototype = Object.getPrototypeOf(targetElement); const descriptor = Object.getOwnPropertyDescriptor(prototype, 'value'); if (descriptor && descriptor.set) { descriptor.set.call(targetElement, newValue); } else { targetElement.value = newValue; } targetElement.selectionStart = targetElement.selectionEnd = start + c.length; targetElement.dispatchEvent(new Event('input', { bubbles: true, cancelable: true })); targetElement.dispatchEvent(new Event('change', { bubbles: true, cancelable: true })); } dispatchKeyEvent(targetElement, 'keyup', c, keyCode); return true;
    }

    // --- SPLASH INICIAL (Mantido Super Animado) ---
    const splash = document.createElement('div'); splash.id = 'bmSplash'; /* ... innerHTML mantido ... */
    splash.innerHTML = `<div id="bmSplashContent"><img id="bmSplashImg" src="https://i.imgur.com/RUWcJ6e.png"/> <div id="bmSplashTexts"> <div id="bmSplashTitle">Paraná Tools</div> <div id="bmSplashSubtitle">AutoEditor Simulado</div> </div> <div id="bmLoadingBar"><div id="bmLoadingProgress"></div></div> </div> <div id="bmSplashBgEffect"></div><div class="bmSplashGrid"></div>`;
    document.body.appendChild(splash);

    // --- CSS INJETADO (FINALMENTE LINDO!) ---
    const css = `
        /* Splash Animado */
        #bmSplashBgEffect { position: absolute; inset: 0; overflow: hidden; z-index: 1; background: radial-gradient(circle, #2a1a4f 0%, #0a0514 70%); opacity: 0; animation: bgSplashEntry 5s ease-out forwards; } @keyframes bgSplashEntry { 0% { opacity: 0; transform: scale(1.1); } 40% { opacity: 1; transform: scale(1); } 100% { opacity: 1; } } .bmSplashGrid { position: absolute; inset: -200px; z-index: 2; background-image: linear-gradient(rgba(138, 43, 226, 0.08) 1px, transparent 1px), linear-gradient(90deg, rgba(138, 43, 226, 0.08) 1px, transparent 1px); background-size: 60px 60px; opacity: 0; animation: gridFadeMove 8s ease-out forwards 0.5s; } @keyframes gridFadeMove { 0% { opacity: 0; background-position: 0 0; } 50% { opacity: 0.6; } 100% { opacity: 0.4; background-position: -120px -120px; } }
        #bmSplash { position: fixed; inset: 0; background:transparent; display:flex; align-items:center; justify-content:center; z-index:99999; overflow:hidden; animation: splashHide 0.8s cubic-bezier(0.6, -0.28, 0.735, 0.045) forwards 4.8s; } #bmSplashContent { z-index: 3; display:flex; flex-direction:column; align-items:center; justify-content:center; perspective: 1000px; } #bmSplashImg { width:180px; margin-bottom: 25px; filter: drop-shadow(0 8px 30px rgba(160, 86, 247, 0.7)); opacity: 0; transform: scale(0.6) rotateZ(-30deg) translateY(50px); animation: logoSuperEntry 2.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.5s, logoFloatBob 2s ease-in-out infinite alternate 2.7s; } @keyframes logoSuperEntry { 0% { opacity: 0.5; transform: scale(0.6) rotateZ(-30deg) translateY(50px); } 60% { opacity: 1; transform: scale(1.15) rotateZ(10deg) translateY(0px); } 80% { transform: scale(0.95) rotateZ(-5deg); } 100% { opacity: 1; transform: scale(1) rotateZ(0deg); } } @keyframes logoFloatBob { from { transform: translateY(0px) scale(1); filter: drop-shadow(0 8px 30px rgba(160, 86, 247, 0.7)); } to { transform: translateY(-8px) scale(1.02); filter: drop-shadow(0 12px 35px rgba(160, 86, 247, 0.8)); } }
        #bmSplashTexts { opacity: 0; transform: translateY(30px) scale(0.95); animation: textsSuperAppear 1s cubic-bezier(0.23, 1, 0.32, 1) forwards 2.9s; text-align: center; } #bmSplashTitle { font-size: 2.9em; font-weight: 900; letter-spacing: 1px; margin-bottom: 6px; font-family:'Segoe UI Black', Arial, sans-serif; color:#fff; text-shadow: 0 0 12px rgba(220, 180, 255, 0.8); background: linear-gradient(45deg, #e0cffc, #a056f7); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } #bmSplashSubtitle { font-size: 1.5em; font-weight: 300; color: #e0cffc; font-family:'Segoe UI Light', Arial, sans-serif; letter-spacing: 0.8px; animation: subtitleGlow 2s ease-in-out infinite alternate 3.5s; } @keyframes textsSuperAppear { to { opacity: 1; transform: translateY(0) scale(1); } } @keyframes subtitleGlow { from { opacity: 0.8; } to { opacity: 1; text-shadow: 0 0 6px rgba(220, 180, 255, 0.6); } }
        #bmLoadingBar { width: 280px; height: 8px; background-color: rgba(255, 255, 255, 0.08); border-radius: 4px; margin-top: 45px; overflow: hidden; opacity: 0; transform: scaleX(0); animation: barSuperAppear 0.7s ease-out forwards 3.7s; box-shadow: inset 0 1px 3px rgba(0,0,0,0.4); } #bmLoadingProgress { width: 0%; height: 100%; background: linear-gradient(90deg, #a056f7, #f8c3ff); border-radius: 4px; animation: loadingAnimFinal 1.1s cubic-bezier(0.65, 0.05, 0.36, 1) forwards 3.8s; position: relative; overflow: hidden;} #bmLoadingProgress::after { content: ''; position: absolute; top: 0; left: -50%; width: 50%; height: 100%; background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0) 100%); transform: skewX(-25deg); animation: shimmer 1.5s infinite; animation-delay: 4s;} @keyframes barSuperAppear { to { opacity: 1; transform: scaleX(1); } } @keyframes loadingAnimFinal { from { width: 0%; } to { width: 100%; } } @keyframes shimmer { 0% { left: -70%; } 100% { left: 120%; } } @keyframes splashHide { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.9); visibility: hidden; } }

        /* Alertas (Com entrada/saída mais bonitas) */
        #bmAlertOverlay { position: fixed; inset: 0; background: rgba(10, 5, 20, 0.7); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: flex; align-items: center; justify-content: center; z-index: 100001; opacity: 0; pointer-events: none; transition: opacity 0.4s ease-out; } #bmAlertOverlay.bmAlertFadeIn { opacity: 1; pointer-events: auto; } #bmAlertOverlay.bmAlertFadeOut { opacity: 0; pointer-events: none; }
        #bmAlertBox { background: linear-gradient(150deg, #2c2c31, #1e1e20); color: #fff; padding: 30px 40px 35px 40px; border-radius: 12px; border: 1px solid #4a4a4f; box-shadow: 0 12px 40px rgba(0, 0, 0, 0.7); min-width: 320px; max-width: 480px; text-align: center; font-family: 'Segoe UI', sans-serif; opacity: 0; transform: scale(0.8) translateY(-20px) rotateX(-10deg); transition: opacity 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); } #bmAlertBox.bmAlertEnter { opacity: 1; transform: scale(1) translateY(0) rotateX(0deg); } #bmAlertBox.bmAlertExit { opacity: 0; transform: scale(0.9) translateY(15px) rotateX(5deg); }
        .bmAlertIcon { width: 45px; height: 45px; border-radius: 50%; margin: 0 auto 18px auto; display: flex; align-items: center; justify-content: center; font-size: 1.6em; font-weight: bold; color: #fff; box-shadow: 0 4px 10px rgba(0,0,0,0.4); animation: iconPopIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.2s backwards; }
        @keyframes iconPopIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .bmAlertIcon.info { background: linear-gradient(135deg, #58a6ff, #3c8ce7); } .bmAlertIcon.success { background: linear-gradient(135deg, #56d364, #2ea043); } .bmAlertIcon.warning { background: linear-gradient(135deg, #f1c40f, #d4ac0d); color: #333; } .bmAlertIcon.error { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        #bmAlertMessage { font-size: 1.15em; line-height: 1.6; margin: 0 0 30px 0; color: #eee; }
        #bmAlertCloseBtn { /* Estilo similar aos botões principais */ padding: 12px 30px; font-size: 1em; font-weight: bold; background: linear-gradient(145deg, #9a3bf6, #7022b6); border: none; border-radius:8px; color: #fff; text-shadow: 0 1px 3px rgba(0,0,0,0.4); cursor:pointer; transition: all 0.15s ease-out; box-shadow: 0 4px 9px rgba(0,0,0,0.6), inset 0 1px 1px rgba(255,255,255,0.15); letter-spacing: 0.5px; } #bmAlertCloseBtn:hover { filter: brightness(1.2) saturate(1.2); transform: translateY(-2px) scale(1.03); box-shadow: 0 7px 14px rgba(138, 43, 226, 0.5), inset 0 1px 1px rgba(255,255,255,0.25); } #bmAlertCloseBtn:active { transform: translateY(0px) scale(0.98); filter: brightness(0.9); box-shadow: 0 2px 5px rgba(138, 43, 226, 0.4), inset 0 1px 2px rgba(0,0,0,0.2); }

        /* UI Principal (Super Linda, Menor) */
        #bmWrapper {
            position:fixed; top:20px; right:20px;
            width: 290px; /* <<----- LARGURA FINAL REDUZIDA */
            border:1px solid #555; /* Borda mais clara */
            border-radius:14px; /* Mais redondo */
            box-shadow:0 12px 45px rgba(0,0,0,0.85); /* Sombra mais intensa */
            font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color:#f0f0f0;
            opacity:0; transform: perspective(800px) translateX(70px) rotateY(-25deg) scale(0.9); /* Entrada 3D */
            transition:opacity 0.7s cubic-bezier(0.165, 0.84, 0.44, 1), transform 0.7s cubic-bezier(0.165, 0.84, 0.44, 1); /* Animação mais longa */
            z-index:99998; overflow: hidden; /* Revertido */
            background: linear-gradient(155deg, #2e2e33, #1c1c1f);
        }
        #bmWrapper.show { opacity:1; transform: perspective(800px) translateX(0) rotateY(0deg) scale(1); }
        #bmWrapper > div:not(#bmResizeHandle) { border-radius: inherit; overflow: hidden; }
        #bmHeader { cursor:move; padding:10px 15px; background: rgba(10, 10, 12, 0.9); backdrop-filter: blur(6px); border-bottom:1px solid #555; font-size:1em; font-weight: 600; text-align:center; border-radius:14px 14px 0 0; user-select: none; position: relative; display: flex; align-items: center; justify-content: center; } #bmHeader span:not(#bmMinimizeBtn) { flex-grow: 1; text-align: center; color: #f5f5f5; text-shadow: 0 1px 1px rgba(0,0,0,0.6); } #bmMinimizeBtn { font-size: 1.7em; font-weight: bold; color: #ccc; cursor: pointer; padding: 0 8px; line-height: 1; transition: color 0.2s ease, transform 0.35s cubic-bezier(0.175, 0.885, 0.32, 1.275); user-select: none; margin-left: auto; transform: translateY(-1px) rotate(0deg); } #bmMinimizeBtn:hover { color: #fff; transform: translateY(-1px) scale(1.2) rotate(180deg); } #bmWrapper.minimized #bmMinimizeBtn { transform: translateY(-1px) rotate(180deg); } #bmWrapper.minimized #bmMinimizeBtn:hover { transform: translateY(-1px) scale(1.2) rotate(0deg); }
        #bmContent { padding: 18px; background:rgba(42, 42, 46, 0.98); border-radius: 0 0 14px 14px; transition: opacity 0.3s ease-out, padding 0.3s ease-out, max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); max-height: 600px; overflow-y: auto; overflow-x: hidden; }
        #bmWrapper.minimized { height: auto !important; min-height: 0 !important; background: rgba(10, 10, 12, 0.95); border-color: #555; } #bmWrapper.minimized #bmContent { opacity: 0; padding-top: 0; padding-bottom: 0; max-height: 0; border-width: 0; margin: 0; overflow: hidden; } #bmWrapper.minimized #bmHeader { border-bottom: none; border-radius: 14px; }
        /* Handle de Resize REMOVIDO */
        #bmContent textarea, #bmContent input[type="number"] { width:100%; margin-bottom:15px; padding:12px; font-size:1em; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; background:rgba(18, 18, 20, 0.9); border:1px solid #666; border-radius:8px; color:#f8f8f8; box-sizing:border-box; resize: vertical; transition: all 0.3s ease; box-shadow: inset 0 2px 6px rgba(0,0,0,0.7); } #bmContent textarea { min-height: 90px; } #bmContent textarea:focus, #bmContent input[type="number"]:focus { outline:none; border-color: #c89bff; background-color: rgba(0,0,0,0.8); box-shadow: 0 0 0 4px rgba(199, 155, 255, 0.3), inset 0 2px 6px rgba(0,0,0,0.7); }
        #bmContent button { width:100%; padding:13px; margin-top: 10px; font-size:1.05em; font-weight: bold; background: linear-gradient(145deg, #a056f7, #7a2fd0); border: none; border-radius:9px; color: #fff; text-shadow: 0 1px 3px rgba(0,0,0,0.5); cursor:pointer; transition: all 0.15s ease-out; box-sizing: border-box; box-shadow: 0 4px 10px rgba(0,0,0,0.65), inset 0 1px 1px rgba(255,255,255,0.2); letter-spacing: 0.6px; } #bmContent button:disabled { cursor: not-allowed; opacity: 0.4; background: #555 !important; box-shadow: inset 0 2px 4px rgba(0,0,0,0.4) !important; transform: none !important; color: #999; filter: grayscale(80%); } #bmContent button:not(:disabled):hover { filter: brightness(1.25) saturate(1.2); transform: translateY(-3px) scale(1.015); box-shadow: 0 8px 18px rgba(138, 43, 226, 0.6), inset 0 1px 1px rgba(255,255,255,0.3); } #bmContent button:not(:disabled):active { transform: translateY(0px) scale(0.97); filter: brightness(0.9); box-shadow: 0 2px 5px rgba(138, 43, 226, 0.5), inset 0 1px 3px rgba(0,0,0,0.3); }
        #bmToggleWrapper, #bmDarkModeToggleWrapper { display:flex; align-items:center; gap:12px; margin-bottom:15px; cursor: pointer; padding: 8px 12px; border-radius: 9px; transition: background-color 0.25s ease; } #bmToggleWrapper:hover, #bmDarkModeToggleWrapper:hover { background-color: rgba(138, 43, 226, 0.2); } #bmToggleImg, #bmDarkModeToggleImg { width:20px; height:20px; border:2px solid #a056f7; border-radius:6px; background:transparent; transition: all .3s cubic-bezier(0.175, 0.885, 0.32, 1.275); display: flex; align-items: center; justify-content: center; flex-shrink: 0; position: relative; } #bmToggleImg.active::after, #bmDarkModeToggleImg.active::after { content: '✔'; position: absolute; font-size: 15px; color: #fff; text-shadow: 0 0 4px rgba(0,0,0,0.5); opacity: 0; transform: scale(0.5) rotate(-180deg); animation: checkSuperAppear 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards 0.1s; } #bmToggleImg.active, #bmDarkModeToggleImg.active { background: #a056f7; border-color: #c89bff; transform: rotate(10deg) scale(1.05); box-shadow: 0 0 8px rgba(160, 86, 247, 0.5); } @keyframes checkSuperAppear { to { opacity: 1; transform: scale(1) rotate(0deg); } } #bmToggleText, #bmDarkModeToggleText { font-size:1.05em; color:#f0f0f0; user-select:none; line-height: 1.2; font-weight: 500; }
        /* Countdowns */ .bmCountdownNumber { /* ... */ position: absolute; bottom: 75px; left: 50%; transform: translateX(-50%); font-family: 'Segoe UI Black', sans-serif; color: #8A2BE2; font-size: 2.8em; opacity: 0; animation: countPopZoom 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; z-index: 10; text-shadow: 0 0 10px rgba(138, 43, 226, 0.7); } @keyframes countPopZoom { 0% { opacity: 0; transform: translateX(-50%) scale(0.5) rotate(-15deg); } 60% { opacity: 1; transform: translateX(-50%) scale(1.1) rotate(5deg); } 100% { opacity: 0; transform: translateX(-50%) scale(1) rotate(0deg); } } .bmCorrectionCountdownNumber { /* ... */ position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Segoe UI Black', sans-serif; color: #4ecdc4; font-size: 5em; opacity: 0; animation: correctionCountPop 0.9s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; z-index: 100002; text-shadow: 0 0 15px rgba(78, 205, 196, 0.7); pointer-events: none; } @keyframes correctionCountPop { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6) rotate(10deg); } 60% { opacity: 1; transform: translate(-50%, -50%) scale(1.1) rotate(-3deg); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1) rotate(0deg); } }
        /* Overlay Stealth */ #bmOv { /* ... */ position:fixed;top:0;left:0; width:100%;height:100%; background:rgba(0,0,0,.9); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); display:flex;flex-direction:column; align-items:center;justify-content:center; z-index:100000; opacity: 0; animation: ovFadeInSmooth 0.5s ease-out forwards; } #bmOvContent { opacity: 0; transform: translateY(20px); animation: ovContentSlideUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards 0.3s; text-align: center; } #bmOv img { max-width:60%; max-height:45%; border-radius: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.4); } #bmOv p { color: #ddd; font-family: 'Segoe UI', sans-serif; text-align: center; margin-top: 20px; max-width: 400px; line-height: 1.5; } #bmOv button { margin-top:25px; padding: 10px 25px; font-size: 1em; background: #8A2BE2; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background 0.2s ease, transform 0.15s ease; font-weight: bold; width: auto; } #bmOv button:hover { background:#7022b6; transform:scale(1.05); } #bmOv button:active { transform: scale(0.98); } @keyframes ovFadeInSmooth { from{opacity:0} to{opacity:1} } @keyframes ovContentSlideUp { from{opacity:0; transform: translateY(20px);} to{opacity:1; transform: translateY(0);} }
        /* Stealth Mode Claro */ #bmWrapper.stealth-mode { /* ... */ background: #f0f0f0; border-color: #ccc; color: #333; animation: none; } #bmWrapper.stealth-mode #bmHeader { background: #dcdcdc; border-color: #ccc; color: #333; } #bmWrapper.stealth-mode #bmContent { background: #e9e9e9; } #bmWrapper.stealth-mode textarea, #bmWrapper.stealth-mode input[type="number"] { background: #fff; border-color: #bbb; color: #222; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); } #bmWrapper.stealth-mode textarea:focus, #bmWrapper.stealth-mode input[type="number"]:focus { border-color: #666; background-color: #fff; box-shadow: 0 0 0 3px rgba(100, 100, 100, 0.2), inset 0 1px 2px rgba(0,0,0,0.1); } #bmWrapper.stealth-mode button { border: 2px solid #888; color: #444; background: #e0e0e0; box-shadow: none; text-shadow: none; background-image: none; } #bmWrapper.stealth-mode button:disabled { border-color: #ccc; color: #999; background: #f0f0f0; } #bmWrapper.stealth-mode button:not(:disabled):hover { background: #ccc; color: #111; border-color: #777; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15); transform: translateY(-1px); } #bmWrapper.stealth-mode button:not(:disabled):active { background: #bbb; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); transform: translateY(0px) scale(0.99); } #bmWrapper.stealth-mode #bmToggleWrapper:hover, #bmWrapper.stealth-mode #bmDarkModeToggleWrapper:hover { background-color: rgba(0, 0, 0, 0.05); } #bmWrapper.stealth-mode #bmToggleImg, #bmWrapper.stealth-mode #bmDarkModeToggleImg { border-color: #999; } #bmWrapper.stealth-mode #bmToggleImg.active, #bmWrapper.stealth-mode #bmDarkModeToggleImg.active { background: #777; border-color: #777; transform: scale(0.9); } #bmWrapper.stealth-mode #bmToggleImg.active::after, #bmWrapper.stealth-mode #bmDarkModeToggleImg.active::after { color: #f0f0f0; } #bmWrapper.stealth-mode #bmToggleText, #bmWrapper.stealth-mode #bmDarkModeToggleText { color: #555; } #bmWrapper.stealth-mode.minimized #bmHeader { background: #dcdcdc; }

        /* Dark Mode */ /* ... Estilos Dark Mode mantidos ... */
        body.bm-dark-mode { --blue-light: #58a6ff; --green: #347d39; --white: #1c1c1c; --blue-dark: #c9d1d9; background-color: var(--white) !important; color: var(--blue-dark) !important; } body.bm-dark-mode ::selection { background-color: var(--blue-light); color: #111; } body.bm-dark-mode section#main, body.bm-dark-mode main { background-color: var(--white) !important; } body.bm-dark-mode nav.sc-gEvEer { background-color: #151a21 !important; border-bottom: 1px solid #333; } body.bm-dark-mode nav.sc-eqUAAy span.bar { background-color: var(--blue-dark) !important; } body.bm-dark-mode .jss1, body.bm-dark-mode .jss3, body.bm-dark-mode .jss5, body.bm-dark-mode .jss6, body.bm-dark-mode .jss10, body.bm-dark-mode .jss15, body.bm-dark-mode .jss16, body.bm-dark-mode .jss17, body.bm-dark-mode .jss19, body.bm-dark-mode .jss20, body.bm-dark-mode .jss21, body.bm-dark-mode .jss23, body.bm-dark-mode .jss24, body.bm-dark-mode .jss26, body.bm-dark-mode .jss27, body.bm-dark-mode .jss30, body.bm-dark-mode .jss31, body.bm-dark-mode .jss33, body.bm-dark-mode .jss34, body.bm-dark-mode .jss35, body.bm-dark-mode .jss37, body.bm-dark-mode .jss38, body.bm-dark-mode .jss40, body.bm-dark-mode .jss41, body.bm-dark-mode .jss42, body.bm-dark-mode .jss43, body.bm-dark-mode .jss45, body.bm-dark-mode .jss46, body.bm-dark-mode .jss47, body.bm-dark-mode .jss48, body.bm-dark-mode .jss51, body.bm-dark-mode .jss52, body.bm-dark-mode .jss53, body.bm-dark-mode .jss54, body.bm-dark-mode .jss55, body.bm-dark-mode .jss56, body.bm-dark-mode .jss57, body.bm-dark-mode .jss59, body.bm-dark-mode .jss60, body.bm-dark-mode div[style*="background-color: white"], body.bm-dark-mode div[style*="background-color: var(--white)"] { background-color: #22272e !important; color: var(--blue-dark) !important; border-color: #444 !important; } body.bm-dark-mode p, body.bm-dark-mode h3, body.bm-dark-mode h4, body.bm-dark-mode h5, body.bm-dark-mode h6, body.bm-dark-mode label, body.bm-dark-mode div[variant="subtitle1"], body.bm-dark-mode span:not([style*="background-color"]):not(#bmMinimizeBtn), body.bm-dark-mode .MuiTypography-root:not(.jss46 p):not(.jss56):not(.jss60 p), body.bm-dark-mode .ql-editor { color: var(--blue-dark) !important; } body.bm-dark-mode h3[style*="color: var(--blue-light)"], body.bm-dark-mode h6[style*="color: var(--blue-light)"] { color: var(--blue-light) !important; } body.bm-dark-mode textarea.jss17, body.bm-dark-mode textarea.jss31, body.bm-dark-mode textarea#outlined-multiline-static { background-color: #181c21 !important; color: #c9d1d9 !important; border: 1px solid #444 !important; caret-color: #eee; } body.bm-dark-mode textarea.jss17:focus, body.bm-dark-mode textarea.jss31:focus, body.bm-dark-mode textarea#outlined-multiline-static:focus { border-color: var(--blue-light) !important; box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.3) !important; } body.bm-dark-mode .jss19 input.MuiInputBase-input, body.bm-dark-mode .jss33 input.MuiInputBase-input { background-color: transparent !important; color: #c9d1d9 !important; border: none !important; } body.bm-dark-mode .jss19 .MuiOutlinedInput-notchedOutline, body.bm-dark-mode .jss33 .MuiOutlinedInput-notchedOutline { border-color: #444 !important; } body.bm-dark-mode .jss19 .Mui-focused .MuiOutlinedInput-notchedOutline, body.bm-dark-mode .jss33 .Mui-focused .MuiOutlinedInput-notchedOutline { border-color: var(--blue-light) !important; box-shadow: 0 0 0 1px rgba(88, 166, 255, 0.3) !important; } body.bm-dark-mode button { transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, filter 0.2s ease !important; } body.bm-dark-mode button[style*="background: white"] { background: #333a45 !important; color: var(--blue-light) !important; border-color: #555 !important; } body.bm-dark-mode button[style*="background: white"]:hover { background: #444c56 !important; border-color: var(--blue-light) !important; } body.bm-dark-mode button[style*="background: var(--green)"] { background: var(--green) !important; color: #fff !important; border-width: 0px !important; } body.bm-dark-mode button[style*="background: var(--green)"]:hover { filter: brightness(1.15); } body.bm-dark-mode button[style*="background: var(--blue-light)"] { background: var(--blue-light) !important; color: #111 !important; } body.bm-dark-mode button.jss21, body.bm-dark-mode button.jss35 { background-color: transparent !important; color: var(--blue-light) !important; border: 1px solid var(--blue-light) !important; } body.bm-dark-mode button.jss21:hover, body.bm-dark-mode button.jss35:hover { background-color: rgba(88, 166, 255, 0.1) !important; } body.bm-dark-mode button.jss26, body.bm-dark-mode button.jss40 { background-color: #333a45 !important; color: #c9d1d9 !important; border: 1px solid #555 !important; } body.bm-dark-mode button.jss26:hover, body.bm-dark-mode button.jss40:hover { background-color: #444c56 !important; } body.bm-dark-mode button:disabled { background-color: #333 !important; color: #777 !important; opacity: 0.7 !important; border-color: #555 !important; filter: grayscale(50%); }
        body.bm-dark-mode .MuiPaper-root.MuiAccordion-root { background-color: #282e35 !important; color: var(--blue-dark) !important; } body.bm-dark-mode .MuiAccordionSummary-root { border-bottom: 1px solid #444 !important; } body.bm-dark-mode .MuiAccordionSummary-expandIcon { color: var(--blue-dark) !important; } body.bm-dark-mode .jss42, body.bm-dark-mode .jss56 { color: #56d364 !important; } body.bm-dark-mode span[style*="background-color"][style*="cursor: pointer"] { color: #111 !important; padding: 0.05em 0.1em; border-radius: 2px; text-shadow: none !important; } body.bm-dark-mode span[style*="background-color: rgb(206, 242, 213)"] { background-color: rgba(206, 242, 213, 0.9) !important; } body.bm-dark-mode span[style*="background-color: rgb(225, 182, 252)"] { background-color: rgba(225, 182, 252, 0.9) !important; } body.bm-dark-mode span[style*="background-color: rgb(237, 147, 50)"] { background-color: rgba(237, 147, 50, 0.8) !important; } body.bm-dark-mode span[style*="background-color: rgb(180, 187, 250)"] { background-color: rgba(180, 187, 250, 0.9) !important; } body.bm-dark-mode .jss46 p.MuiTypography-root, body.bm-dark-mode .jss60 p.MuiTypography-root { color: #111 !important; font-weight: 500 !important; } body.bm-dark-mode .jss45, body.bm-dark-mode .jss59 { background-color: #282e35 !important; padding: 5px; border-radius: 4px; } body.bm-dark-mode .jss46, body.bm-dark-mode .jss60 { border: 1px solid rgba(0,0,0,0.2) !important; opacity: 0.9; }
        body.bm-dark-mode .MuiDialog-paper { background-color: #22272e !important; } body.bm-dark-mode .MuiDialogTitle-root h2 { color: #eee !important; } body.bm-dark-mode .MuiDialogContent-root { color: var(--blue-dark) !important; } body.bm-dark-mode div[style*="background-color: var(--blue-light)"][style*="color: var(--white)"] { background-color: #151a21 !important; color: #eee !important; } body.bm-dark-mode ::-webkit-scrollbar { width: 10px; height: 10px; } body.bm-dark-mode ::-webkit-scrollbar-track { background: #282e35; } body.bm-dark-mode ::-webkit-scrollbar-thumb { background: #555; border-radius: 5px; border: 2px solid #282e35; } body.bm-dark-mode ::-webkit-scrollbar-thumb:hover { background: #777; } body.bm-dark-mode div[vw].enabled div[vw-access-button].active { filter: invert(1) hue-rotate(180deg); } body.bm-dark-mode footer #footer1, body.bm-dark-mode footer #footer { background-color: #151a21 !important; color: #aaa !important; } body.bm-dark-mode footer a { color: #77aaff !important; } body.bm-dark-mode footer .blue-line, body.bm-dark-mode footer .green-line { opacity: 0.5; }

        /* Splash Correção (Fundo Opaco + Animações Lindas) */
        #bmCorrectionSplash { position: fixed; inset: 0; background: #0A0514; /* FUNDO OPACO */ /* backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); Removido */ display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100000; opacity: 0; transition: opacity 0.5s ease-out; font-family: 'Segoe UI', sans-serif; color: #eee; overflow: hidden; /* Para grid animado */ }
        #bmCorrectionSplash::before { /* Grid animado */ content: ''; position: absolute; inset: -200px; z-index: 1; background-image: linear-gradient(rgba(138, 43, 226, 0.06) 1px, transparent 1px), linear-gradient(90deg, rgba(138, 43, 226, 0.06) 1px, transparent 1px); background-size: 50px 50px; animation: gridFadeMoveCorrection 10s linear infinite; }
        @keyframes gridFadeMoveCorrection { 0% { background-position: 0 0; opacity: 0; } 50% { opacity: 0.4; } 100% { background-position: -100px -100px; opacity: 0; } }
        #bmCorrectionSplash.visible { opacity: 1; }
        #bmCorrectionSplash .splash-content { z-index: 2; text-align: center; transform: scale(0.9); opacity: 0; animation: splashContentEntry 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.1s forwards; } #bmCorrectionSplash h2 { font-size: 2em; font-weight: 600; color: #e0cffc; margin-bottom: 35px; text-shadow: 0 0 12px rgba(160, 86, 247, 0.7); animation: pulseGlow 2.5s ease-in-out infinite alternate; }
        @keyframes pulseGlow{ from { opacity: 0.9; } to { opacity: 1; text-shadow: 0 0 16px rgba(200, 150, 255, 0.8); } }
        #bmCorrectionSplash .word-display { display: flex; align-items: center; justify-content: center; gap: 30px; margin-bottom: 40px; min-height: 100px; perspective: 600px; } #bmCorrectionSplash .word-box { background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 12px; padding: 20px 35px; min-width: 180px; text-align: center; box-shadow: 0 5px 20px rgba(0,0,0,0.4); backdrop-filter: blur(3px); } #bmCorrectionSplash .word-box .label { font-size: 0.9em; color: #bbb; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; } #bmCorrectionSplash .word-box .word { font-size: 1.8em; font-weight: 500; color: #fff; min-height: 1.5em; display: inline-block; } #bmCorrectionSplash .word-arrow { font-size: 3em; color: #a056f7; opacity: 0.9; transform: scale(1); transition: transform 0.3s ease; text-shadow: 0 0 8px rgba(160, 86, 247, 0.6); } #bmCorrectionSplash .word-display:hover .word-arrow { transform: scale(1.15); }
        /* Animação palavras: Slide + Fade */
        #bmCorrectionSplash .word { display: block; /* Garante que o transform funcione bem */ opacity: 1; transform: translateY(0%); transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
        #bmCorrectionSplash .word.exiting { opacity: 0; transform: translateY(-80%); }
        #bmCorrectionSplash .word.entering { opacity: 0; transform: translateY(80%); animation: wordSlideIn 0.4s ease-out forwards 0.1s; }
        @keyframes wordSlideIn { to { opacity: 1; transform: translateY(0); } }
        /* Spinner (Aplicando Alterações) */ #bmCorrectionSplash .spinner { width: 45px; height: 45px; border: 5px solid rgba(255, 255, 255, 0.2); border-left-color: #a056f7; border-radius: 50%; animation: spin 0.8s linear infinite; margin: 15px auto 25px auto; } @keyframes spin { to { transform: rotate(360deg); } } #bmCorrectionSplash .applying-text { font-size: 1.4em; color: #ddd; letter-spacing: 0.5px; animation: pulseGlow 2s ease-in-out infinite alternate; } @keyframes splashContentEntry { from { transform: scale(0.9) translateY(15px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
        /* Animação entrada elementos UI */ .bmFadeInSlideUp { opacity: 0; transform: translateY(15px); animation: fadeInSlideUpItem 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards; } @keyframes fadeInSlideUpItem { to { opacity: 1; transform: translateY(0); } }
    `;
    const styleTag = document.createElement('style'); styleTag.textContent = css; document.head.appendChild(styleTag);

    // --- LÓGICA PRINCIPAL E UI ---
    const splashTimeout = 5000;
    setTimeout(() => {
        if (document.body.contains(splash)) { splash.remove(); }

        const wrapper = document.createElement('div'); wrapper.id = 'bmWrapper';
        wrapper.innerHTML = `
            <div id="bmHeader"> <span>Paraná Colado V1</span> <span id="bmMinimizeBtn" title="Minimizar/Expandir">-</span> </div>
            <div id="bmContent">
                 <textarea id="bmText" placeholder="Cole o texto aqui..." class="bmFadeInSlideUp" style="animation-delay: 0.1s;"></textarea>
                 <input id="bmDelay" type="number" step="0.001" value="0.001" min="0.001" placeholder="Delay (s)" class="bmFadeInSlideUp" style="animation-delay: 0.15s;">
                 <div id="bmToggleWrapper" class="bmFadeInSlideUp" style="animation-delay: 0.2s;"> <div id="bmToggleImg"></div> <span id="bmToggleText">Modo Disfarçado</span> </div>
                 <div id="bmDarkModeToggleWrapper" class="bmFadeInSlideUp" style="animation-delay: 0.25s;"> <div id="bmDarkModeToggleImg"></div> <span id="bmDarkModeToggleText">Modo Escuro Página</span> </div>
                 <button id="bmBtn" class="bmFadeInSlideUp" style="animation-delay: 0.3s;">Iniciar Digitação</button>
                 <button id="bmBtnCorrect" class="bmFadeInSlideUp" style="animation-delay: 0.35s;">Corrigir Automaticamente</button>
                 </div>
        `;
        document.body.appendChild(wrapper);
        const bmContent = document.getElementById('bmContent');
        const bmMinimizeBtn = document.getElementById('bmMinimizeBtn');
        // bmResizeHandle REMOVIDO
        const header = document.getElementById('bmHeader');

        setTimeout(() => wrapper.classList.add('show'), 50);

        // Lógicas de Arrastar, Minimizar, Modo Disfarçado, Dark Mode (Mantidas e Ajustadas)
        let isDragging = false; let dragStartX, dragStartY, initialLeft, initialTop; header.onmousedown = e => { if (e.target === bmMinimizeBtn || bmMinimizeBtn.contains(e.target) /* || e.target === bmResizeHandle || bmResizeHandle.contains(e.target) REMOVIDO */ ) return; isDragging = true; dragStartX = e.clientX; dragStartY = e.clientY; initialLeft = wrapper.offsetLeft; initialTop = wrapper.offsetTop; header.style.cursor = 'grabbing'; document.addEventListener('mousemove', onDragMove); document.addEventListener('mouseup', onDragUp); e.preventDefault(); }; function onDragMove(e) { if (!isDragging) return; const dx = e.clientX - dragStartX; const dy = e.clientY - dragStartY; wrapper.style.left = initialLeft + dx + 'px'; wrapper.style.top = initialTop + dy + 'px'; } function onDragUp() { if (isDragging) { isDragging = false; header.style.cursor = 'move'; document.removeEventListener('mousemove', onDragMove); document.removeEventListener('mouseup', onDragUp); } }
        if(bmMinimizeBtn && wrapper){ bmMinimizeBtn.onclick = (e) => { e.stopPropagation(); const isMinimized = wrapper.classList.toggle('minimized'); bmMinimizeBtn.textContent = isMinimized ? '+' : '-'; bmMinimizeBtn.title = isMinimized ? 'Expandir' : 'Minimizar'; if (stealthOn) { setTimeout(() => { rect = wrapper.classList.contains('minimized') ? header.getBoundingClientRect() : wrapper.getBoundingClientRect(); }, 360); } }; }
        // Lógica de Redimensionar REMOVIDA
        const toggleWrapper = document.getElementById('bmToggleWrapper'); const toggleBox = document.getElementById('bmToggleImg'); let stealthOn = false; let firstTimeStealth = true; let rect = null; function handleStealthMouseMove(ev) { if (!ev || typeof ev.clientX === 'undefined' || typeof ev.clientY === 'undefined') { return; } if (!stealthOn || !wrapper || !document.body.contains(wrapper)) { exitStealth(); return; } if (!rect) { rect = wrapper.classList.contains('minimized') ? header.getBoundingClientRect() : wrapper.getBoundingClientRect(); if (!rect || rect.width === 0 || rect.height === 0) return; } const mouseX = ev.clientX; const mouseY = ev.clientY; const isInside = (rect && mouseX >= rect.left && mouseX <= rect.right && mouseY >= rect.top && mouseY <= rect.bottom); if (isInside) { if (wrapper.style.opacity === '0') { wrapper.style.opacity = 1; wrapper.style.pointerEvents = 'auto'; } } else { if (wrapper.style.opacity !== '0') { rect = wrapper.classList.contains('minimized') ? header.getBoundingClientRect() : wrapper.getBoundingClientRect(); if (rect && rect.width > 0 && rect.height > 0) { wrapper.style.opacity = 0; wrapper.style.pointerEvents = 'none'; } } } } function enterStealth() { if (!wrapper || !document.body.contains(wrapper)) return; stealthOn = true; wrapper.classList.add('stealth-mode'); toggleBox.classList.add('active'); wrapper.style.opacity = 1; wrapper.style.pointerEvents = 'auto'; rect = wrapper.classList.contains('minimized') ? header.getBoundingClientRect() : wrapper.getBoundingClientRect(); if (!rect || rect.width === 0 || rect.height === 0) { stealthOn = false; wrapper.classList.remove('stealth-mode'); toggleBox.classList.remove('active'); showCustomAlert("Erro Modo Disfarçado.", "error"); return; } document.addEventListener('mousemove', handleStealthMouseMove); wrapper.style.opacity = 0; wrapper.style.pointerEvents = 'none'; } function exitStealth() { stealthOn = false; document.removeEventListener('mousemove', handleStealthMouseMove); if (wrapper && document.body.contains(wrapper)) { wrapper.classList.remove('stealth-mode'); toggleBox.classList.remove('active'); wrapper.style.opacity = 1; wrapper.style.pointerEvents = 'auto'; } rect = null; } function showStealthOverlay() { const ov = document.createElement('div'); ov.id = 'bmOv'; ov.innerHTML = `<div id="bmOvContent"><img src="https://i.imgur.com/RquEok4.gif" alt="Demo"/> <p>O Modo Disfarçado oculta...</p> <button id="bmOvBtn">Entendido</button></div>`; document.body.appendChild(ov); document.getElementById('bmOvBtn').onclick = () => { ov.style.opacity = 0; setTimeout(() => { if (document.body.contains(ov)){ ov.remove(); } }, 500); enterStealth(); }; } toggleWrapper.onclick = () => { if (!stealthOn) { if (firstTimeStealth) { firstTimeStealth = false; showStealthOverlay(); } else { enterStealth(); } } else { exitStealth(); } };
        const darkModeToggleWrapper = document.getElementById('bmDarkModeToggleWrapper'); const darkModeToggleBox = document.getElementById('bmDarkModeToggleImg'); let isDarkModeOn = false; darkModeToggleWrapper.onclick = () => { isDarkModeOn = !isDarkModeOn; darkModeToggleBox.classList.toggle('active', isDarkModeOn); document.body.classList.toggle('bm-dark-mode', isDarkModeOn); console.log("Dark Mode:", isDarkModeOn ? "ON" : "OFF"); };

        // Lógica Botão "Iniciar Digitação" (Mantida Rápida)
        const startButton = document.getElementById('bmBtn'); const correctButton = document.getElementById('bmBtnCorrect');
        startButton.onclick = async function() { /* ... código mantido ... */
             const text = document.getElementById('bmText').value; const delayInput = parseFloat(document.getElementById('bmDelay').value); const delay = (!isNaN(delayInput) && delayInput * 1000 >= MIN_DELAY) ? delayInput * 1000 : MIN_DELAY; if (!text) { showCustomAlert('Texto vazio!', 'error'); return; } if (!activeEl || !document.body.contains(activeEl)) { showCustomAlert('Clique no campo alvo antes!', 'error'); return; } this.disabled = true; if (correctButton) correctButton.disabled = true;
             for (let n = 3; n >= 1; n--) { const cnt = document.createElement('div'); cnt.className = 'bmCountdownNumber'; cnt.textContent = n; wrapper.appendChild(cnt); await new Promise(r => setTimeout(r, 700)); if (wrapper.contains(cnt)) wrapper.removeChild(cnt); await new Promise(r => setTimeout(r, 100)); } let typingCompleted = true;
             try { activeEl.focus({ preventScroll: true }); for (let i = 0; i < text.length; i++) { const char = text[i]; const success = sendChar(char); if (!success) { typingCompleted = false; break; } if (delay > 0) await new Promise(r => setTimeout(r, delay)); } if (typingCompleted) { showCustomAlert('Digitação concluída!', 'success'); } else { showCustomAlert('Digitação interrompida por erro.', 'error'); } } catch (error) { console.error("Erro na digitação:", error); showCustomAlert("Erro durante digitação.", 'error'); } finally { this.disabled = false; if (correctButton) correctButton.disabled = false; }
        };


        // --- LÓGICA CORREÇÃO AUTOMÁTICA (Com Splash de Correção Lindo) ---
        let correctionSplashEl = null;
        function showCorrectionSplash(initialMessage = "Preparando correção...") { /* ... código mantido ... */ if (correctionSplashEl) { const h2 = correctionSplashEl.querySelector('h2'); if (h2) h2.textContent = initialMessage; const spinner = correctionSplashEl.querySelector('.spinner'); const applyText = correctionSplashEl.querySelector('.applying-text'); const wordDisplay = correctionSplashEl.querySelector('.word-display'); if(spinner) spinner.style.display = 'none'; if(applyText) applyText.style.display = 'none'; if(wordDisplay) wordDisplay.style.display = 'flex'; if (!correctionSplashEl.classList.contains('visible')) { correctionSplashEl.style.opacity = 0; void correctionSplashEl.offsetWidth; correctionSplashEl.classList.add('visible'); } return; } correctionSplashEl = document.createElement('div'); correctionSplashEl.id = 'bmCorrectionSplash'; correctionSplashEl.innerHTML = ` <div class="splash-content"> <h2>${initialMessage}</h2> <div class="word-display"> <div class="word-box"> <div class="label">Original</div> <div class="word" id="bmCorrectionBefore">---</div> </div> <div class="word-arrow">→</div> <div class="word-box"> <div class="label">Correção</div> <div class="word" id="bmCorrectionAfter">---</div> </div> </div> <div class="spinner" style="display: none;"></div> <div class="applying-text" style="display: none;"></div> </div>`; document.body.appendChild(correctionSplashEl); void correctionSplashEl.offsetWidth; correctionSplashEl.classList.add('visible'); }
        async function updateCorrectionSplash(beforeWord, afterWord) { /* *** LÓGICA REVISADA PARA NOVA ANIMAÇÃO *** */ if (!correctionSplashEl) return; const beforeEl = correctionSplashEl.querySelector('#bmCorrectionBefore'); const afterEl = correctionSplashEl.querySelector('#bmCorrectionAfter'); if (!beforeEl || !afterEl) return; const currentBefore = beforeEl.textContent; const currentAfter = afterEl.textContent; if (currentBefore !== beforeWord || currentAfter !== afterWord) { beforeEl.className = 'word word-out'; afterEl.className = 'word word-out'; await new Promise(r => setTimeout(r, 300)); beforeEl.textContent = beforeWord; afterEl.textContent = afterWord; beforeEl.className = 'word word-in-prepare'; afterEl.className = 'word word-in-prepare'; void beforeEl.offsetWidth; beforeEl.className = 'word word-in'; afterEl.className = 'word word-in'; await new Promise(r => setTimeout(r, 400)); beforeEl.className = 'word'; afterEl.className = 'word'; } else { beforeEl.className = 'word'; afterEl.className = 'word'; } }
        function showApplyingChangesState() { /* ... código mantido ... */ if (!correctionSplashEl) return; const content = correctionSplashEl.querySelector('.splash-content'); if(content) { content.innerHTML = `<h2>Finalizando...</h2> <div class="spinner"></div> <div class="applying-text">Aplicando Alterações...</div>`; content.style.opacity = 0; content.style.transform = 'scale(0.9)'; void content.offsetWidth; content.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; content.style.opacity = 1; content.style.transform = 'scale(1)'; } }
        function hideCorrectionSplash() { /* ... código mantido ... */ if (!correctionSplashEl) return; correctionSplashEl.classList.remove('visible'); setTimeout(() => { if (correctionSplashEl && document.body.contains(correctionSplashEl)) { correctionSplashEl.remove(); } correctionSplashEl = null; }, 500); }

        correctButton.onclick = async function() {
            const btnCorrect = this; btnCorrect.disabled = true; if (startButton) startButton.disabled = true;
            console.log('Iniciando correção automática...');
            // const waitDelay = STEP_DELAY; // REMOVIDO
            let concludeButtonExists = false; try { /* ... verificação Concluir ... */ const allButtons = document.querySelectorAll('button'); for (const btn of allButtons) { if (btn.textContent.trim() === "Concluir") { concludeButtonExists = true; console.log("Botão 'Concluir' encontrado."); break; } } } catch (e) { console.error("Erro ao procurar 'Concluir':", e); }
            let correctionFlowStarted = false; let needsCountdown = false;

            showCorrectionSplash("Verificando Status...");
            await new Promise(r => setTimeout(r, 150)); // Pausa mínima

            if (!concludeButtonExists) { /* ... Lógica 'CORRIGIR ONLINE' ... */
                 console.log("'Concluir' não encontrado..."); try { const correctorButtons = document.querySelectorAll('button'); let foundCorrectorButton = null; let foundWaitingButton = null; for (const button of correctorButtons) { const buttonText = button.textContent; if (buttonText && buttonText.includes("CORRIGIR ONLINE")) { if (buttonText.trim() === "CORRIGIR ONLINE") { foundCorrectorButton = button; } else { foundWaitingButton = button; break; } } } if (foundWaitingButton) { console.log("'CORRIGIR ONLINE' em espera."); showCustomAlert("'Corrigir Online' Em processo de espera...", 'info'); hideCorrectionSplash(); btnCorrect.disabled = false; if (startButton) startButton.disabled = false; return; } else if (foundCorrectorButton) { console.log("'CORRIGIR ONLINE' pronto."); await updateCorrectionSplash("---", "Iniciando Online..."); await new Promise(r=>setTimeout(r, 150)); foundCorrectorButton.click(); console.log("Clicou. Esperando 'PROCESSANDO' sumir..."); correctionFlowStarted = true; const processingSelector = 'div.sc-kAyceB.kEYIQb'; await waitForElementToDisappear(processingSelector, 30000); console.log("'PROCESSANDO' desapareceu."); await updateCorrectionSplash("Online OK", "Contagem..."); needsCountdown = true; console.log("Contagem regressiva 3s..."); for (let n = 3; n >= 1; n--) { const cnt = document.createElement('div'); cnt.className = 'bmCorrectionCountdownNumber'; cnt.textContent = n; document.body.appendChild(cnt); await new Promise(r => setTimeout(r, 950)); if (document.body.contains(cnt)) document.body.removeChild(cnt); } console.log("Contagem finalizada."); } else { console.log("'CORRIGIR ONLINE' não encontrado."); await updateCorrectionSplash("---", "Pronto"); await new Promise(r=>setTimeout(r, 150)); } } catch (error) { hideCorrectionSplash(); if (error.message.includes('Timeout')) { showCustomAlert("Timeout esperando 'PROCESSANDO'.", 'error'); } else { console.error("Erro 'CORRIGIR ONLINE':", error); showCustomAlert("Erro ao processar 'CORRIGIR ONLINE'.", 'error'); } btnCorrect.disabled = false; if (startButton) startButton.disabled = false; return; }
            } else { await updateCorrectionSplash("---", "Pronto"); await new Promise(r=>setTimeout(r, 150)); }

            let targetTextarea; try { targetTextarea = await waitForElement('textarea[id*="multiline"][class*="jss"]', 2000); } catch (error) { showCustomAlert('ERRO: Textarea não encontrada!', 'error'); hideCorrectionSplash(); btnCorrect.disabled = false; if (startButton) startButton.disabled = false; return; } console.log('Textarea encontrada.'); activeEl = targetTextarea; if (correctionSplashEl) { correctionSplashEl.querySelector('h2').textContent = `Corrigindo...`; } console.log("Procurando spans..."); const errorSpans = document.querySelectorAll('span[style*="background-color: rgb"][style*="cursor: pointer"]'); let correctedCount = 0; let errorCount = 0;
            if (errorSpans.length === 0) { /* ... mensagem inicial ... */ console.log('Nenhum span encontrado.'); hideCorrectionSplash(); if (!correctionFlowStarted && !concludeButtonExists) { showCustomAlert('Nenhum erro (span) encontrado.', 'info'); } else { showCustomAlert('Nenhum erro (span) adicional encontrado.', 'info'); } btnCorrect.disabled = false; if (startButton) startButton.disabled = false; return; } console.log(`Encontrados ${errorSpans.length} spans.`);

            // --- Loop Principal de Correção (VELOCIDADE MÁXIMA) ---
            for (const errorSpan of errorSpans) {
                 if (btnCorrect.disabled === false) { console.log("Interrompido."); break; }
                 if (!document.body.contains(errorSpan) || errorSpan.offsetParent === null) { continue; }
                try {
                    const errorText = errorSpan.textContent.trim();
                    await updateCorrectionSplash(errorText, "...");

                    // *** 1. SCROLL SUAVE PARA O ERRO ***
                    errorSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    if (SCROLL_DELAY > 0) await new Promise(r => setTimeout(r, SCROLL_DELAY));

                    if (!errorText) { errorCount++; continue; } // Pula se texto vazio
                    const currentTextValue = targetTextarea.value; const errorIndex = currentTextValue.indexOf(errorText); if (errorIndex === -1) { errorCount++; continue; } // Pula se não achou

                    errorSpan.click(); await new Promise(r => setTimeout(r, MIN_DELAY)); // Mínimo

                    let suggestionList;
                    try { suggestionList = await waitForElement('ul#menu-list-grow', 500); }
                    catch (e) { errorCount++; await updateCorrectionSplash(errorText, "Sem Sugestão"); document.body.click(); await new Promise(r => setTimeout(r, MIN_DELAY*10)); continue; } // Pausa mínima antes de pular

                    const suggestionItems = suggestionList.querySelectorAll('li');
                    const validSuggestions = Array.from(suggestionItems).slice(1).map(li => li.textContent.trim()).filter(text => text.length > 0 && text.length < 50); // Filtra sugestões muito longas também

                    if (validSuggestions.length > 0) {
                        const chosenSuggestion = validSuggestions[0];
                        await updateCorrectionSplash(errorText, chosenSuggestion); // Mostra correção
                        // await new Promise(r => setTimeout(r, MIN_DELAY)); // Remove pausa visual

                        // *** 2. FOCO SEM SCROLL + SELEÇÃO ***
                        targetTextarea.focus({ preventScroll: true }); await new Promise(r => setTimeout(r, MIN_DELAY));
                        targetTextarea.selectionStart = errorIndex; targetTextarea.selectionEnd = errorIndex + errorText.length; await new Promise(r => setTimeout(r, MIN_DELAY));

                        // *** 3. RE-SCROLL (AUTO) ***
                        targetTextarea.scrollIntoView({ behavior: 'auto', block: 'center' }); await new Promise(r => setTimeout(r, MIN_DELAY));

                        // *** 4. EDIÇÃO ***
                        activeEl = targetTextarea; await simulateBackspace(targetTextarea);
                        // await new Promise(r => setTimeout(r, MIN_DELAY)); // Remove pausa extra
                        activeEl = targetTextarea;
                        for (const char of chosenSuggestion) { if (btnCorrect.disabled === false) break; sendChar(char); if(MIN_DELAY > 0) await new Promise(r => setTimeout(r, MIN_DELAY)); }
                        if (btnCorrect.disabled === false) break;
                        correctedCount++;
                    } else { errorCount++; await updateCorrectionSplash(errorText, "N/A"); }

                    document.body.click(); await new Promise(r => setTimeout(r, MIN_DELAY * 2));
                } catch (error) { console.error(`Erro span "${errorSpan?.textContent?.trim()}":`, error); errorCount++; try { document.body.click(); } catch(e){} await new Promise(r => setTimeout(r, MIN_DELAY)); }
                 // await new Promise(r => setTimeout(r, MIN_DELAY)); // Remove pausa entre erros
            } // Fim loop for

            // --- Tela "Aplicando Alterações" e Finalização ---
             showApplyingChangesState();
             const randomDelay = Math.floor(Math.random() * 2000) + 1000; // 1s a 3s (reduzido)
             console.log(`Aguardando ${randomDelay}ms...`);
             await new Promise(r => setTimeout(r, randomDelay));
             hideCorrectionSplash();

             console.log('Correção finalizada.'); if (errorCount > 0) { showCustomAlert("Um ou mais erros não puderam ser corrigidos. Por favor, os corrija manualmente.", 'warning'); } else { if (correctedCount > 0) { showCustomAlert(`Correção finalizada! ${correctedCount} erros processados com sucesso.`, 'success'); } else { showCustomAlert('Nenhum erro necessitou de correção ou todos já estavam corretos.', 'info'); } }

            btnCorrect.disabled = false; if (startButton) startButton.disabled = false;

        }; // Fim onclick correctButton

    }, splashTimeout); // Fim do setTimeout principal

})(); // Fim da IIFE
